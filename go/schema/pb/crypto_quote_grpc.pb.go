// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package schema

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CryptoQuoteClient is the client API for CryptoQuote service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoQuoteClient interface {
	GetCryptoQuote(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (*CryptoQuotePayload, error)
	GetCryptoQuotes(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (*CryptoQuotePayloads, error)
	StreamGetCryptoQuotes(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (CryptoQuote_StreamGetCryptoQuotesClient, error)
	CreateCryptoQuote(ctx context.Context, in *CryptoQuotePayload, opts ...grpc.CallOption) (*CryptoQuoteResponse, error)
	CreateCryptoQuotes(ctx context.Context, in *CryptoQuotePayloads, opts ...grpc.CallOption) (*CryptoQuoteResponse, error)
	StreamCreateCryptoQuotes(ctx context.Context, opts ...grpc.CallOption) (CryptoQuote_StreamCreateCryptoQuotesClient, error)
	DeleteCryptoQuotes(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (*CryptoQuoteResponse, error)
}

type cryptoQuoteClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoQuoteClient(cc grpc.ClientConnInterface) CryptoQuoteClient {
	return &cryptoQuoteClient{cc}
}

func (c *cryptoQuoteClient) GetCryptoQuote(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (*CryptoQuotePayload, error) {
	out := new(CryptoQuotePayload)
	err := c.cc.Invoke(ctx, "/crypto_quote.CryptoQuote/GetCryptoQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoQuoteClient) GetCryptoQuotes(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (*CryptoQuotePayloads, error) {
	out := new(CryptoQuotePayloads)
	err := c.cc.Invoke(ctx, "/crypto_quote.CryptoQuote/GetCryptoQuotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoQuoteClient) StreamGetCryptoQuotes(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (CryptoQuote_StreamGetCryptoQuotesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CryptoQuote_ServiceDesc.Streams[0], "/crypto_quote.CryptoQuote/StreamGetCryptoQuotes", opts...)
	if err != nil {
		return nil, err
	}
	x := &cryptoQuoteStreamGetCryptoQuotesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CryptoQuote_StreamGetCryptoQuotesClient interface {
	Recv() (*CryptoQuotePayload, error)
	grpc.ClientStream
}

type cryptoQuoteStreamGetCryptoQuotesClient struct {
	grpc.ClientStream
}

func (x *cryptoQuoteStreamGetCryptoQuotesClient) Recv() (*CryptoQuotePayload, error) {
	m := new(CryptoQuotePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cryptoQuoteClient) CreateCryptoQuote(ctx context.Context, in *CryptoQuotePayload, opts ...grpc.CallOption) (*CryptoQuoteResponse, error) {
	out := new(CryptoQuoteResponse)
	err := c.cc.Invoke(ctx, "/crypto_quote.CryptoQuote/CreateCryptoQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoQuoteClient) CreateCryptoQuotes(ctx context.Context, in *CryptoQuotePayloads, opts ...grpc.CallOption) (*CryptoQuoteResponse, error) {
	out := new(CryptoQuoteResponse)
	err := c.cc.Invoke(ctx, "/crypto_quote.CryptoQuote/CreateCryptoQuotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoQuoteClient) StreamCreateCryptoQuotes(ctx context.Context, opts ...grpc.CallOption) (CryptoQuote_StreamCreateCryptoQuotesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CryptoQuote_ServiceDesc.Streams[1], "/crypto_quote.CryptoQuote/StreamCreateCryptoQuotes", opts...)
	if err != nil {
		return nil, err
	}
	x := &cryptoQuoteStreamCreateCryptoQuotesClient{stream}
	return x, nil
}

type CryptoQuote_StreamCreateCryptoQuotesClient interface {
	Send(*CryptoQuotePayload) error
	CloseAndRecv() (*CryptoQuoteResponse, error)
	grpc.ClientStream
}

type cryptoQuoteStreamCreateCryptoQuotesClient struct {
	grpc.ClientStream
}

func (x *cryptoQuoteStreamCreateCryptoQuotesClient) Send(m *CryptoQuotePayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cryptoQuoteStreamCreateCryptoQuotesClient) CloseAndRecv() (*CryptoQuoteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CryptoQuoteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cryptoQuoteClient) DeleteCryptoQuotes(ctx context.Context, in *CryptoQuoteFilter, opts ...grpc.CallOption) (*CryptoQuoteResponse, error) {
	out := new(CryptoQuoteResponse)
	err := c.cc.Invoke(ctx, "/crypto_quote.CryptoQuote/DeleteCryptoQuotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoQuoteServer is the server API for CryptoQuote service.
// All implementations must embed UnimplementedCryptoQuoteServer
// for forward compatibility
type CryptoQuoteServer interface {
	GetCryptoQuote(context.Context, *CryptoQuoteFilter) (*CryptoQuotePayload, error)
	GetCryptoQuotes(context.Context, *CryptoQuoteFilter) (*CryptoQuotePayloads, error)
	StreamGetCryptoQuotes(*CryptoQuoteFilter, CryptoQuote_StreamGetCryptoQuotesServer) error
	CreateCryptoQuote(context.Context, *CryptoQuotePayload) (*CryptoQuoteResponse, error)
	CreateCryptoQuotes(context.Context, *CryptoQuotePayloads) (*CryptoQuoteResponse, error)
	StreamCreateCryptoQuotes(CryptoQuote_StreamCreateCryptoQuotesServer) error
	DeleteCryptoQuotes(context.Context, *CryptoQuoteFilter) (*CryptoQuoteResponse, error)
	mustEmbedUnimplementedCryptoQuoteServer()
}

// UnimplementedCryptoQuoteServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoQuoteServer struct {
}

func (UnimplementedCryptoQuoteServer) GetCryptoQuote(context.Context, *CryptoQuoteFilter) (*CryptoQuotePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptoQuote not implemented")
}
func (UnimplementedCryptoQuoteServer) GetCryptoQuotes(context.Context, *CryptoQuoteFilter) (*CryptoQuotePayloads, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCryptoQuotes not implemented")
}
func (UnimplementedCryptoQuoteServer) StreamGetCryptoQuotes(*CryptoQuoteFilter, CryptoQuote_StreamGetCryptoQuotesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamGetCryptoQuotes not implemented")
}
func (UnimplementedCryptoQuoteServer) CreateCryptoQuote(context.Context, *CryptoQuotePayload) (*CryptoQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCryptoQuote not implemented")
}
func (UnimplementedCryptoQuoteServer) CreateCryptoQuotes(context.Context, *CryptoQuotePayloads) (*CryptoQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCryptoQuotes not implemented")
}
func (UnimplementedCryptoQuoteServer) StreamCreateCryptoQuotes(CryptoQuote_StreamCreateCryptoQuotesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamCreateCryptoQuotes not implemented")
}
func (UnimplementedCryptoQuoteServer) DeleteCryptoQuotes(context.Context, *CryptoQuoteFilter) (*CryptoQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCryptoQuotes not implemented")
}
func (UnimplementedCryptoQuoteServer) mustEmbedUnimplementedCryptoQuoteServer() {}

// UnsafeCryptoQuoteServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoQuoteServer will
// result in compilation errors.
type UnsafeCryptoQuoteServer interface {
	mustEmbedUnimplementedCryptoQuoteServer()
}

func RegisterCryptoQuoteServer(s grpc.ServiceRegistrar, srv CryptoQuoteServer) {
	s.RegisterService(&CryptoQuote_ServiceDesc, srv)
}

func _CryptoQuote_GetCryptoQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CryptoQuoteFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoQuoteServer).GetCryptoQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crypto_quote.CryptoQuote/GetCryptoQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoQuoteServer).GetCryptoQuote(ctx, req.(*CryptoQuoteFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoQuote_GetCryptoQuotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CryptoQuoteFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoQuoteServer).GetCryptoQuotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crypto_quote.CryptoQuote/GetCryptoQuotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoQuoteServer).GetCryptoQuotes(ctx, req.(*CryptoQuoteFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoQuote_StreamGetCryptoQuotes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CryptoQuoteFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CryptoQuoteServer).StreamGetCryptoQuotes(m, &cryptoQuoteStreamGetCryptoQuotesServer{stream})
}

type CryptoQuote_StreamGetCryptoQuotesServer interface {
	Send(*CryptoQuotePayload) error
	grpc.ServerStream
}

type cryptoQuoteStreamGetCryptoQuotesServer struct {
	grpc.ServerStream
}

func (x *cryptoQuoteStreamGetCryptoQuotesServer) Send(m *CryptoQuotePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _CryptoQuote_CreateCryptoQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CryptoQuotePayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoQuoteServer).CreateCryptoQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crypto_quote.CryptoQuote/CreateCryptoQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoQuoteServer).CreateCryptoQuote(ctx, req.(*CryptoQuotePayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoQuote_CreateCryptoQuotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CryptoQuotePayloads)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoQuoteServer).CreateCryptoQuotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crypto_quote.CryptoQuote/CreateCryptoQuotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoQuoteServer).CreateCryptoQuotes(ctx, req.(*CryptoQuotePayloads))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoQuote_StreamCreateCryptoQuotes_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CryptoQuoteServer).StreamCreateCryptoQuotes(&cryptoQuoteStreamCreateCryptoQuotesServer{stream})
}

type CryptoQuote_StreamCreateCryptoQuotesServer interface {
	SendAndClose(*CryptoQuoteResponse) error
	Recv() (*CryptoQuotePayload, error)
	grpc.ServerStream
}

type cryptoQuoteStreamCreateCryptoQuotesServer struct {
	grpc.ServerStream
}

func (x *cryptoQuoteStreamCreateCryptoQuotesServer) SendAndClose(m *CryptoQuoteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cryptoQuoteStreamCreateCryptoQuotesServer) Recv() (*CryptoQuotePayload, error) {
	m := new(CryptoQuotePayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CryptoQuote_DeleteCryptoQuotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CryptoQuoteFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoQuoteServer).DeleteCryptoQuotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crypto_quote.CryptoQuote/DeleteCryptoQuotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoQuoteServer).DeleteCryptoQuotes(ctx, req.(*CryptoQuoteFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoQuote_ServiceDesc is the grpc.ServiceDesc for CryptoQuote service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoQuote_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crypto_quote.CryptoQuote",
	HandlerType: (*CryptoQuoteServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCryptoQuote",
			Handler:    _CryptoQuote_GetCryptoQuote_Handler,
		},
		{
			MethodName: "GetCryptoQuotes",
			Handler:    _CryptoQuote_GetCryptoQuotes_Handler,
		},
		{
			MethodName: "CreateCryptoQuote",
			Handler:    _CryptoQuote_CreateCryptoQuote_Handler,
		},
		{
			MethodName: "CreateCryptoQuotes",
			Handler:    _CryptoQuote_CreateCryptoQuotes_Handler,
		},
		{
			MethodName: "DeleteCryptoQuotes",
			Handler:    _CryptoQuote_DeleteCryptoQuotes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamGetCryptoQuotes",
			Handler:       _CryptoQuote_StreamGetCryptoQuotes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamCreateCryptoQuotes",
			Handler:       _CryptoQuote_StreamCreateCryptoQuotes_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "crypto_quote.proto",
}
