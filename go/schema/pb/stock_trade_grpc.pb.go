// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package schema

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// StockTradeClient is the client API for StockTrade service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StockTradeClient interface {
	GetStockTrade(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (*StockTradePayload, error)
	GetStockTrades(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (*StockTradePayloads, error)
	StreamGetStockTrade(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (StockTrade_StreamGetStockTradeClient, error)
	CreateStockTrade(ctx context.Context, in *StockTradePayload, opts ...grpc.CallOption) (*StockTradeResponse, error)
	CreateStockTrades(ctx context.Context, in *StockTradePayloads, opts ...grpc.CallOption) (*StockTradeResponse, error)
	StreamCreateStockTrades(ctx context.Context, opts ...grpc.CallOption) (StockTrade_StreamCreateStockTradesClient, error)
	DeleteStockTrades(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (*StockTradeResponse, error)
}

type stockTradeClient struct {
	cc grpc.ClientConnInterface
}

func NewStockTradeClient(cc grpc.ClientConnInterface) StockTradeClient {
	return &stockTradeClient{cc}
}

func (c *stockTradeClient) GetStockTrade(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (*StockTradePayload, error) {
	out := new(StockTradePayload)
	err := c.cc.Invoke(ctx, "/stock_trade.StockTrade/GetStockTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockTradeClient) GetStockTrades(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (*StockTradePayloads, error) {
	out := new(StockTradePayloads)
	err := c.cc.Invoke(ctx, "/stock_trade.StockTrade/GetStockTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockTradeClient) StreamGetStockTrade(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (StockTrade_StreamGetStockTradeClient, error) {
	stream, err := c.cc.NewStream(ctx, &StockTrade_ServiceDesc.Streams[0], "/stock_trade.StockTrade/StreamGetStockTrade", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTradeStreamGetStockTradeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StockTrade_StreamGetStockTradeClient interface {
	Recv() (*StockTradePayload, error)
	grpc.ClientStream
}

type stockTradeStreamGetStockTradeClient struct {
	grpc.ClientStream
}

func (x *stockTradeStreamGetStockTradeClient) Recv() (*StockTradePayload, error) {
	m := new(StockTradePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockTradeClient) CreateStockTrade(ctx context.Context, in *StockTradePayload, opts ...grpc.CallOption) (*StockTradeResponse, error) {
	out := new(StockTradeResponse)
	err := c.cc.Invoke(ctx, "/stock_trade.StockTrade/CreateStockTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockTradeClient) CreateStockTrades(ctx context.Context, in *StockTradePayloads, opts ...grpc.CallOption) (*StockTradeResponse, error) {
	out := new(StockTradeResponse)
	err := c.cc.Invoke(ctx, "/stock_trade.StockTrade/CreateStockTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockTradeClient) StreamCreateStockTrades(ctx context.Context, opts ...grpc.CallOption) (StockTrade_StreamCreateStockTradesClient, error) {
	stream, err := c.cc.NewStream(ctx, &StockTrade_ServiceDesc.Streams[1], "/stock_trade.StockTrade/StreamCreateStockTrades", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTradeStreamCreateStockTradesClient{stream}
	return x, nil
}

type StockTrade_StreamCreateStockTradesClient interface {
	Send(*StockTradePayload) error
	CloseAndRecv() (*StockTradeResponse, error)
	grpc.ClientStream
}

type stockTradeStreamCreateStockTradesClient struct {
	grpc.ClientStream
}

func (x *stockTradeStreamCreateStockTradesClient) Send(m *StockTradePayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stockTradeStreamCreateStockTradesClient) CloseAndRecv() (*StockTradeResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StockTradeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockTradeClient) DeleteStockTrades(ctx context.Context, in *StockTradeFilter, opts ...grpc.CallOption) (*StockTradeResponse, error) {
	out := new(StockTradeResponse)
	err := c.cc.Invoke(ctx, "/stock_trade.StockTrade/DeleteStockTrades", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StockTradeServer is the server API for StockTrade service.
// All implementations must embed UnimplementedStockTradeServer
// for forward compatibility
type StockTradeServer interface {
	GetStockTrade(context.Context, *StockTradeFilter) (*StockTradePayload, error)
	GetStockTrades(context.Context, *StockTradeFilter) (*StockTradePayloads, error)
	StreamGetStockTrade(*StockTradeFilter, StockTrade_StreamGetStockTradeServer) error
	CreateStockTrade(context.Context, *StockTradePayload) (*StockTradeResponse, error)
	CreateStockTrades(context.Context, *StockTradePayloads) (*StockTradeResponse, error)
	StreamCreateStockTrades(StockTrade_StreamCreateStockTradesServer) error
	DeleteStockTrades(context.Context, *StockTradeFilter) (*StockTradeResponse, error)
	mustEmbedUnimplementedStockTradeServer()
}

// UnimplementedStockTradeServer must be embedded to have forward compatible implementations.
type UnimplementedStockTradeServer struct {
}

func (UnimplementedStockTradeServer) GetStockTrade(context.Context, *StockTradeFilter) (*StockTradePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStockTrade not implemented")
}
func (UnimplementedStockTradeServer) GetStockTrades(context.Context, *StockTradeFilter) (*StockTradePayloads, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStockTrades not implemented")
}
func (UnimplementedStockTradeServer) StreamGetStockTrade(*StockTradeFilter, StockTrade_StreamGetStockTradeServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamGetStockTrade not implemented")
}
func (UnimplementedStockTradeServer) CreateStockTrade(context.Context, *StockTradePayload) (*StockTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStockTrade not implemented")
}
func (UnimplementedStockTradeServer) CreateStockTrades(context.Context, *StockTradePayloads) (*StockTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStockTrades not implemented")
}
func (UnimplementedStockTradeServer) StreamCreateStockTrades(StockTrade_StreamCreateStockTradesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamCreateStockTrades not implemented")
}
func (UnimplementedStockTradeServer) DeleteStockTrades(context.Context, *StockTradeFilter) (*StockTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStockTrades not implemented")
}
func (UnimplementedStockTradeServer) mustEmbedUnimplementedStockTradeServer() {}

// UnsafeStockTradeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StockTradeServer will
// result in compilation errors.
type UnsafeStockTradeServer interface {
	mustEmbedUnimplementedStockTradeServer()
}

func RegisterStockTradeServer(s grpc.ServiceRegistrar, srv StockTradeServer) {
	s.RegisterService(&StockTrade_ServiceDesc, srv)
}

func _StockTrade_GetStockTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StockTradeFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockTradeServer).GetStockTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock_trade.StockTrade/GetStockTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockTradeServer).GetStockTrade(ctx, req.(*StockTradeFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _StockTrade_GetStockTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StockTradeFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockTradeServer).GetStockTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock_trade.StockTrade/GetStockTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockTradeServer).GetStockTrades(ctx, req.(*StockTradeFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _StockTrade_StreamGetStockTrade_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StockTradeFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockTradeServer).StreamGetStockTrade(m, &stockTradeStreamGetStockTradeServer{stream})
}

type StockTrade_StreamGetStockTradeServer interface {
	Send(*StockTradePayload) error
	grpc.ServerStream
}

type stockTradeStreamGetStockTradeServer struct {
	grpc.ServerStream
}

func (x *stockTradeStreamGetStockTradeServer) Send(m *StockTradePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _StockTrade_CreateStockTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StockTradePayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockTradeServer).CreateStockTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock_trade.StockTrade/CreateStockTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockTradeServer).CreateStockTrade(ctx, req.(*StockTradePayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _StockTrade_CreateStockTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StockTradePayloads)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockTradeServer).CreateStockTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock_trade.StockTrade/CreateStockTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockTradeServer).CreateStockTrades(ctx, req.(*StockTradePayloads))
	}
	return interceptor(ctx, in, info, handler)
}

func _StockTrade_StreamCreateStockTrades_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StockTradeServer).StreamCreateStockTrades(&stockTradeStreamCreateStockTradesServer{stream})
}

type StockTrade_StreamCreateStockTradesServer interface {
	SendAndClose(*StockTradeResponse) error
	Recv() (*StockTradePayload, error)
	grpc.ServerStream
}

type stockTradeStreamCreateStockTradesServer struct {
	grpc.ServerStream
}

func (x *stockTradeStreamCreateStockTradesServer) SendAndClose(m *StockTradeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stockTradeStreamCreateStockTradesServer) Recv() (*StockTradePayload, error) {
	m := new(StockTradePayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StockTrade_DeleteStockTrades_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StockTradeFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockTradeServer).DeleteStockTrades(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock_trade.StockTrade/DeleteStockTrades",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockTradeServer).DeleteStockTrades(ctx, req.(*StockTradeFilter))
	}
	return interceptor(ctx, in, info, handler)
}

// StockTrade_ServiceDesc is the grpc.ServiceDesc for StockTrade service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StockTrade_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stock_trade.StockTrade",
	HandlerType: (*StockTradeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStockTrade",
			Handler:    _StockTrade_GetStockTrade_Handler,
		},
		{
			MethodName: "GetStockTrades",
			Handler:    _StockTrade_GetStockTrades_Handler,
		},
		{
			MethodName: "CreateStockTrade",
			Handler:    _StockTrade_CreateStockTrade_Handler,
		},
		{
			MethodName: "CreateStockTrades",
			Handler:    _StockTrade_CreateStockTrades_Handler,
		},
		{
			MethodName: "DeleteStockTrades",
			Handler:    _StockTrade_DeleteStockTrades_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamGetStockTrade",
			Handler:       _StockTrade_StreamGetStockTrade_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamCreateStockTrades",
			Handler:       _StockTrade_StreamCreateStockTrades_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "stock_trade.proto",
}
